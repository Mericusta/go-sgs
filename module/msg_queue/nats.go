package moduleMsgQueue

import (
	"errors"
	"fmt"
	"math"
	"time"

	"github.com/Mericusta/go-sgs"
	"github.com/Mericusta/go-sgs/config"
	"github.com/Mericusta/go-stp"
	"github.com/nats-io/nats.go"
	"go.uber.org/zap"
)

const (
	NATS_HEADER_MSG_MODE         = "MODE" // nats 通信的模式：request 模式，publish 模式
	NATS_HEADER_ERROR_NO         = "NATS_HEADER_ERRNO"
	NATS_HEADER_ERROR_MSG        = "NATS_HEADER_ERRMSG"
	NATS_HEADER_MESSAGE_TYPE     = "MESSAGE_TYPE"
	NATS_HEADER_PLAYER_ID        = "PLAYER_ID"
	NATS_HEADER_TRACE_ID         = "TRACE_ID"
	NATS_HEADER_TOKEN            = "TOKEN"
	NATS_HEADER_LISTEN_SUBJECT   = "LISTEN_SUBJECT"   // nats 监听玩家消息的 subject
	NATS_HEADER_REQUEST_UUID     = "REQUEST_UUID"     // 消息 UUID
	NATS_HEADER_LOGIN_TOKEN      = "LOGIN_TOKEN"      // 通过 login 获得的 登录 token
	NATS_HEADER_REQUEST_START_MS = "REQUEST_START_MS" // client actor 收到客户端消息，发往 player actor 处理前的时刻

	NATS_HEADER_REQUEST_RECEIVE_MS  = "REQUEST_RECEIVE_MS"  // player actor 收到 client actor 消息，执行 handler 之前的时刻
	NATS_HEADER_REQUEST_HANDLE_MS   = "REQUEST_HANDLE_MS"   // player actor 执行 handler 后，返回 response 之前的时刻
	NATS_HEADER_REQUEST_FINISHED_MS = "REQUEST_FINISHED_MS" // client actor 收到 response 消息，返回客户端之前的时刻
)

// ModuleNatsService nats 服务模块
// - 监听 nats 指定 subject 的消息
type ModuleNatsService struct {
	// 组合基础模块
	sgs.ModuleBase

	// 实现接口 tag，使用空结构体不需要内存对齐
	_ struct{} `pattern:"implement,ident=Module,except=Run"`

	// 结构体静态变量 tag
	_ struct{} `pattern:"static,ident=Nats"`

	// nats 配置
	config *config.MsgQueueConfig

	// nats 链接
	connection *nats.Conn

	// 订阅的 nats 的 subject 的实例
	subscriptionMap *stp.CMap[string, *nats.Subscription]

	// nats 通信的超时时间
	natsOvertime time.Duration
}

// pattern: static, automatically generated by tags of anonymous members of empty structs
var NatsService *ModuleNatsService

func (*ModuleNatsService) New(mos ...sgs.ModuleOption) *ModuleNatsService {
	mns := &ModuleNatsService{}
	for _, mo := range mos {
		mo(mns)
	}
	return mns
}

// pattern: option, automatically generated by tags of struct member 'url'
func (*ModuleNatsService) WithNatsConfig(c *config.MsgQueueConfig) sgs.ModuleOption {
	return func(m sgs.Module) { m.(*ModuleNatsService).config = c }
}

func (m *ModuleNatsService) Mounted() {
	m.Logger().Debug("OBSERVE: Mounted, dial nats then subscribe subject", zap.Any("config", m.config))

	if m.natsOvertime == 0 {
		m.natsOvertime = time.Second * 5
	}

	// 和 nats 建立链接
	connection, err := nats.Connect(
		m.config.URL,
		nats.ReconnectWait(time.Millisecond*10),
		nats.MaxReconnects(math.MaxInt64),
		nats.PingInterval(m.natsOvertime),
		nats.MaxPingsOutstanding(2),
		nats.Timeout(m.natsOvertime),
		nats.DrainTimeout(m.natsOvertime), // 关闭前处理剩余消息的超时时间
		nats.Name(m.Identify()),
		nats.DisconnectErrHandler(func(conn *nats.Conn, err error) {
			m.Logger().Debug("DisconnectErrHandler")
		}),
		nats.ReconnectHandler(func(conn *nats.Conn) {
			m.Logger().Debug("ReconnectHandler")
		}),
		nats.ClosedHandler(func(conn *nats.Conn) {
			m.Logger().Debug("ClosedHandler")
		}),
	)
	if err != nil {
		// 无法建立链接不提供服务
		panic(fmt.Errorf("connect to nats %v occurs error: %v", m.config.URL, err))
	}

	// 保存链接实例
	m.connection = connection

	// 创建订阅实例 map
	m.subscriptionMap = stp.NewCMap[string, *nats.Subscription]()
}

func (m *ModuleNatsService) HandleEvent(event *sgs.ModuleEvent) {
	switch data := event.Data().(type) {
	case ISubscribeBehavior:
		// 请求开启订阅
		m.handleSubscribeBehavior(data)
	case IUnsubscribeBehavior:
		// 请求关闭订阅
		m.handleUnsubscribeBehavior(data)
	case *nats.Msg:
		// TODO: 需要处理
		// 接收的地方不用担心会被阻塞住
		// 发送的地方容易阻塞，可能由于网络或者 request/response 逻辑会被阻塞住
		// 处理 nats 消息
		m.handleNatsMsg(event.From(), data)
	default:
		m.Logger().Error(sgs.ErrorMsgHandleEventNonImplement)
	}
}

func (m *ModuleNatsService) handleSubscribeBehavior(subscribeBehavior ISubscribeBehavior) {
	if len(subscribeBehavior.Subject()) == 0 || subscribeBehavior.Handler() == nil {
		m.Logger().Error("handleMsgQueueSubscription, invalid subscription", zap.Any("subscription", subscribeBehavior))
		return
	}

	subject := subscribeBehavior.Subject()
	handler := subscribeBehavior.Handler()

	// 检查订阅实例是否已存在
	_, exists := m.subscriptionMap.Get(subject)
	if exists {
		m.Logger().Error("handleMsgQueueSubscription, Subscribe duplicated", zap.Any("subject", subject))
		return
	}

	// 使用 nats 链接订阅 nats 的 subject
	// 由于这里需要使用 m，所以只能采用匿名函数捕获的形式
	sub, err := m.connection.Subscribe(subject, func(natsMsg *nats.Msg) { handler(m, natsMsg) })
	if err != nil {
		m.Logger().Error("handleMsgQueueSubscription, Subscribe occurs error", zap.Error(err), zap.Any("subject", subject))
		return
	}

	// 保存订阅实例
	m.subscriptionMap.Save(subject, sub)

	m.Logger().Info("handleMsgQueueSubscription, Subscribe subject", zap.Any("subject", subject))
}

func (m *ModuleNatsService) handleUnsubscribeBehavior(unsubscribeBehavior IUnsubscribeBehavior) {
	if len(unsubscribeBehavior.Subject()) == 0 {
		m.Logger().Error("handleUnsubscribeBehavior, invalid subscription", zap.Any("subscription", unsubscribeBehavior))
		return
	}

	subject := unsubscribeBehavior.Subject()

	// 检查订阅实例是否已存在
	subscription, _ := m.subscriptionMap.Remove(subject)
	if subscription == nil {
		m.Logger().Error("handleUnsubscribeBehavior, duplicated unsubscribe", zap.Any("subject", subject))
		return
	}

	err := subscription.Drain()
	if err != nil {
		m.Logger().Error("handleUnsubscribeBehavior, subscription.Drain occurs error", zap.Error(err), zap.Any("subject", subject))
	}

	m.Logger().Debug("handleMsgQueueSubscription, unsubscribe subject", zap.Any("subject", subject))
}

func (m *ModuleNatsService) handleNatsMsg(fromIdentify string, natsMsg *nats.Msg) {
	// m.Logger().Debug("OBSERVE: handleNatsMsg", zap.Any("fromIdentify", fromIdentify), zap.Any("natsMsg.Subject", natsMsg.Subject), zap.Any("natsMsg.Header", natsMsg.Header))

	msgMode := natsMsg.Header.Get(NATS_HEADER_MSG_MODE)
	switch msgMode {
	case "request":
		responseNatsMsg, err := m.connection.RequestMsg(natsMsg, m.natsOvertime)
		if err != nil {
			natsMsg.Header.Set(NATS_HEADER_ERROR_NO, "1")
			natsMsg.Header.Set(NATS_HEADER_ERROR_MSG, err.Error())
			m.Logger().Error("handleNatsMsg, RequestMsg occurs error", zap.Error(err), zap.Any("natsMsg.Subject", natsMsg.Subject), zap.Any("natsMsg.Header", natsMsg.Header))
			err = m.SendEvent(sgs.NewModuleEvent(fromIdentify, natsMsg))
		} else {
			err = m.SendEvent(sgs.NewModuleEvent(fromIdentify, responseNatsMsg))
		}
		if err != nil && !errors.Is(err, sgs.ErrorSubjectNotExists) && !errors.Is(err, sgs.ErrorSendEventCanceled) {
			m.Logger().Error("handleNatsMsg, SendEvent occurs error", zap.Error(err), zap.Any("toSubject", fromIdentify), zap.Any("natsMsg.Subject", natsMsg.Subject), zap.Any("responseNatsMsg.Header", responseNatsMsg.Header))
			return
		}
	case "publish":
		err := m.connection.PublishMsg(natsMsg)
		if err != nil {
			m.Logger().Error("handleNatsMsg, PublishMsg occurs error", zap.Error(err), zap.Any("natsMsg.Subject", natsMsg.Subject), zap.Any("natsMsg.Header", natsMsg.Header))
			return
		}
	default:
		m.Logger().Error("handleNatsMsg, unsupported msg code, using publish", zap.Any("mode", msgMode))
		err := m.connection.PublishMsg(natsMsg)
		if err != nil {
			m.Logger().Error("handleNatsMsg, PublishMsg occurs error", zap.Error(err), zap.Any("natsMsg.Subject", natsMsg.Subject), zap.Any("natsMsg.Header", natsMsg.Header))
			return
		}
	}
}

func (m *ModuleNatsService) Unmounted() {
	m.Logger().Debug("OBSERVE: Unmounted")
	if m.subscriptionMap != nil {
		m.subscriptionMap.Range(func(subject string, subscription *nats.Subscription) bool {
			// 清空链接中的消息
			err := subscription.Drain()
			if err != nil {
				m.Logger().Error("Unmount, subscription.Drain occurs error", zap.Error(err), zap.Any("subject", subject))
			}
			return true
		})
	}
}
